// Package main provides a code generator for generating ID types with specific descriptors.
package main

import (
	"fmt"
	"os"
	"strconv"
	"strings"
	"text/template"
)

// Entity represents an entity with a name, short identifier, and kind number.
type Entity struct {
	Name       string
	ShortIdent string
	KindNumber int
}

const (
	expectedParts = 3 // Expected number of parts in each argument (Name, ShortIdent, KindNumber)
)

const tmpl = `// Code generated by generate_kinds.go; DO NOT EDIT.

package model

import "github.com/advdv/sdulid"

{{ range . }}
// {{ .Name }}Desc entity.
type {{ .Name }}Desc struct{}

// KindNumber implementation.
func ({{ .Name }}Desc) KindNumber() uint16 { return {{ .KindNumber }} }

// KindIdent implementation.
func ({{ .Name }}Desc) KindIdent() string { return "{{ .Name | toLower }}" }

// KindShortIdent implementation.
func ({{ .Name }}Desc) KindShortIdent() string { return "{{ .ShortIdent }}" }

{{ end }}

{{ range . }}
// {{ .Name }}ID is a type alias for sdulid.ID[{{ .Name }}Desc].
type {{ .Name }}ID = sdulid.ID[{{ .Name }}Desc]

// Make{{ .Name }}ID creates a new {{ .Name }}ID.
func Make{{ .Name }}ID() {{ .Name }}ID { return sdulid.Make[{{ .Name }}Desc]() }

// Must{{ .Name }}IDFromULID creates a {{ .Name }}ID from a ULID string, panicking if the ULID is invalid.
func Must{{ .Name }}IDFromULID(s string) {{ .Name }}ID { return sdulid.MustFromULID[{{ .Name }}Desc](s) }

// {{ .Name }}IDFromULID creates a {{ .Name }}ID from a ULID string, returning an error if the ULID is invalid.
func {{ .Name }}IDFromULID(s string) ({{ .Name }}ID, error) { return sdulid.FromULID[{{ .Name }}Desc](s) }
{{ end }}
`

func parseArgs(args []string) ([]Entity, error) {
	// Pre-allocate based on number of args
	entities := make([]Entity, 0, len(args))
	kindNumberSet := make(map[int]bool)

	for _, arg := range args {
		parts := strings.Split(arg, ":")
		if len(parts) != expectedParts {
			return nil, fmt.Errorf("invalid argument format: %s, expected format <Name>:<ShortIdent>:<KindNumber>", arg)
		}

		name := parts[0]
		shortIdent := parts[1]
		kindNumber, err := strconv.Atoi(parts[2])
		if err != nil {
			return nil, fmt.Errorf("invalid kind number for %s: %w", name, err)
		}

		// Check for duplicate KindNumber
		if kindNumberSet[kindNumber] {
			return nil, fmt.Errorf("duplicate KindNumber %d for entity %s", kindNumber, name)
		}
		kindNumberSet[kindNumber] = true

		entities = append(entities, Entity{Name: name, ShortIdent: shortIdent, KindNumber: kindNumber})
	}

	return entities, nil
}

func generateFile(outputFileName string, entities []Entity) error {
	// Create the output file
	f, err := os.Create(outputFileName)
	if err != nil {
		return fmt.Errorf("error creating file: %w", err)
	}
	defer f.Close()

	// Parse the template
	t := template.Must(template.New("kinds").Funcs(template.FuncMap{
		"toLower": strings.ToLower,
	}).Parse(tmpl))

	// Execute the template and write to the file
	if err := t.Execute(f, entities); err != nil {
		return fmt.Errorf("error executing template: %w", err)
	}

	return nil
}

func main() {
	if len(os.Args) < 3 { //nolint:mnd
		fmt.Fprintln(os.Stderr, "Usage: go run generate_kinds.go <output_file> <Name:ShortIdent:KindNumber>...")
		os.Exit(1)
	}

	// Get the output file name from the first argument
	outputFileName := os.Args[1]
	// Parse the entity definitions from remaining arguments
	entities, err := parseArgs(os.Args[2:])
	if err != nil {
		fmt.Fprintln(os.Stderr, "Error:", err)
		os.Exit(1)
	}

	// Generate the file
	if err := generateFile(outputFileName, entities); err != nil {
		fmt.Fprintln(os.Stderr, "Error:", err)
		os.Exit(1)
	}
}
